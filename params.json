{"name":"Cassandra-driver-mapping","tagline":"JPA addon for DataStax Java Driver for Cassandra","body":"cassandra-driver-mapping\r\n========================\r\n  \r\nEntity mapping Add-on for the DataStax Java Driver (Driver) for Cassandra (C*).  \r\nThis Add-on allows you to generate schema automatically and persist JPA annotated entities in C*.\r\n\r\nAdd-on is not replacement for the Driver but lightweight utility for it.  \r\nYou still can utilize full power of the Driver API and Datastax documentation.     \r\nMapping Add-on relies on Driver version 2.XXX and JPA 2.1.    \r\n\r\nRead more about [Datastax Java Driver, Cassandra and CQL3](http://www.datastax.com/documentation/gettingstarted/index.html).\r\n\r\n[More Usage Samples in Unit Tests]\r\n(https://github.com/valchkou/cassandra-driver-mapping/blob/master/src/test/java/com/datastax/driver/mapping/)\r\n\r\n### Table of Contents  \r\n- [Features](#features)  \r\n- [Jump Start](#start)  \r\n\t* [Maven Dependency](#jump_maven)\r\n\t* [Init Mapping Session](#jump_init)\r\n\t* [Save](#jump_save)\r\n\t* [Get](#jump_get)\r\n\t* [Delete](#jump_delete)\r\n- [Various Mappings](#mapping)  \r\n\t* [Basic](#mapping_basic)\r\n\t* [Indexes](#mapping_index)\r\n\t* [Compound Primary Key](#mapping_composite)\r\n\t* [Composite Partition Key](#mapping_partition)\r\n\t* [Table Properties](#mapping_properties)\r\n\t* [Override Column Data Type](#mapping_datatype)\r\n\t* [Mixed Case for Column Names](#mapping_mixed)\r\n- [Collections](#collections)\r\n\t* [Mapping](#mapping_collections)\r\n\t* [Optimized operations](#collections_opt)\t\r\n\t\t- [List](#collections_list)\r\n\t\t- [Set](#collections_set)\r\n\t\t- [Map](#collections_map)\r\n- [Optimistic Lock](#lock)\r\n\t* [Lightweight transactions](#lock_transactions)\r\n\t* [@Version](#lock_version)\r\n- [Batch](#batch)\r\n- [Nested Entities](#nested)\r\n- [Mapping Custom Queries](#queries_mapping)  \r\n\t* [How To Run](#queries_howto)\r\n\t* [Any-to-Any and Magic Gnomes](#queries_gnomes)\r\n- [Building Custom Queries](#queries_building)\r\n\t* [CQL String](#queries_cql)\r\n\t* [QueryBuilder (better)](#queries_builder)\t\r\n\t* [QueryBuilder with EntityMetadata (even better)](#queries_meta)\r\n- [Under The Hood](#under)\r\n\t* [Prepared Statement Cache](#pscache)  \r\n\t* [How Entity get synchronized](#sync)  \r\n\t* [Entity Metadata and Data Types](#metadata)  \r\n- [Spring Framework Example](#spring)  \r\n\r\n<a name=\"features\"/>\r\n### Features\r\n\r\nThe features provided by the module include:\r\n\r\n- OM Layer\r\n  \t* Get entity from Cassandra.\r\n  \t* Save entity to Cassandra.\r\n\t* Delete entity from Cassandra.\r\n\t* Run and map custom Queries and ResultSets.\r\n\r\n- Schema Sync\r\n  \t* Automatically create table and indexes from Entity. \r\n  \t* Automatically Alter table and indexes if entity definition has changed.\r\n  \t* Drop table.\r\n\r\nNo mapping files, no scripts, no configuration files.   \r\nYou don't have to worry about creating the Table and Indexes for your Entity manually.  \r\nAll is built-in and taken care of. Entity definition will be automatically [synchronized with C*](#sync).  \r\n\r\n<a name=\"start\"/>\r\n### Jump Start\r\n\r\n<a name=\"jump_maven\"/>\r\n- Maven Dependency.  \r\nInstall in your application from Maven Central using the following dependency:\r\n```xml\r\n    <dependency>\r\n      <groupId>com.valchkou.datastax</groupId>\r\n      <artifactId>cassandra-driver-mapping</artifactId>\r\n      <version>2.1.0-rc1</version>\r\n    </dependency>\r\n```\r\nAll new changes and bugfixes are released within the latest version as soon as coded.\r\nModule versioning policy matches underlying datastax driver core versioning.\r\n\r\n\r\n<a name=\"jump_init\"/>\r\n- Init Mapping Session.  \r\nMappingSession is cheap to instantiate and it is not replacement for the Datastax Session.   \r\nYou can instantiate as many mapping sessions as you want. It's threadsafe.  \r\n```java\r\n\timport com.datastax.driver.core.Session;\r\n\timport com.datastax.driver.mapping.MappingSession;\r\n\t...\r\n    \t\r\n\tSession session; // initialize datastax session.\r\n\tMappingSession mappingSession = new MappingSession(\"keyspace_name\", session);\r\n```  \r\nIf you wish your mapping session do not synchronize your entities with C* you may turn synch off:\r\n```java\r\n\tMappingSession mappingSession = new MappingSession(\"keyspace_name\", session, true);\r\n\t// OR\r\n\tMappingSession mappingSession = new MappingSession(\"keyspace_name\", session);\r\n\tmappingSession.setDoNotSync(true);\r\n```  \r\nUnderlying Datastax Session does all the heavylifting and is expansive.   \r\nPrior using MappingSession you need to open the Datastax Session and create the Keyspace using the standard Datastax Driver API. If you are not familiar with procedure please refer to [Datastax Dcumentation](http://www.datastax.com/documentation/developer/java-driver/2.0/java-driver/quick_start/qsQuickstart_c.html).  \r\nOr look at the [Spring Framework Example](#spring).\r\n\r\n<a name=\"jump_save\"/>\r\n- Save.\r\n```java\r\n\tEntity entity = new Entity();\r\n\tmappingSession.save(entity);\r\n```\r\nOR\r\n```java\r\n\timport com.datastax.driver.mapping.option.WriteOptions;\r\n\timport com.datastax.driver.core.policies.DefaultRetryPolicy;\r\n\timport com.datastax.driver.core.ConsistencyLevel;\r\n\t...\r\n\t// using options\r\n\tWriteOptions options = new WriteOptions()\r\n\t\t.setTtl(300)\r\n\t\t.setTimestamp(42)\r\n\t\t.setConsistencyLevel(ConsistencyLevel.ANY)\r\n\t\t.setRetryPolicy(DefaultRetryPolicy.INSTANCE);\r\n\t\t\r\n\tEntity entity = new Entity();\r\n\tmappingSession.save(entity, options);\r\n```\r\n\r\n<a name=\"jump_get\"/>\r\n- Get.\r\n```java\r\n\tEntity entity = mappingSession.get(Entity.class, id);\r\n```\r\nOR\r\n```java\r\n\timport com.datastax.driver.mapping.option.ReadOptions;\r\n\timport com.datastax.driver.core.policies.DefaultRetryPolicy;\r\n\timport com.datastax.driver.core.ConsistencyLevel;\r\n\t...\r\n\t// using options\r\n\tReadOptions options = new ReadOptions()\r\n\t\t.setConsistencyLevel(ConsistencyLevel.ANY)\r\n\t\t.setRetryPolicy(DefaultRetryPolicy.INSTANCE);\r\n\t\t\r\n\tEntity entity = mappingSession.get(Entity.class, id, options);\r\n```\r\n\r\n<a name=\"jump_delete\"/>\r\n- Delete.\r\n```java\r\n\tmappingSession.delete(entity);\t\r\n```\r\n\r\n<a name=\"mapping\"/>\r\n### Various Mappings\r\n\r\n\tIMPORTANT!!!  \r\n\t- If entity or field is not annotated it will provide its name as default.    \r\n\t- Id field is required and must be annotated with @Id or @EmbeddedId.\r\n\t- Index name must be unique within the keyspace.  \r\n\t- C* supports only single-column-index.\r\n\r\n\r\n<a name=\"mapping_basic\"/>\t  \t  \r\n#### Basic Mapping\r\n```java\r\nimport javax.persistence.Id;\r\nimport javax.persistence.Table;\r\nimport javax.persistence.Column\r\n\r\n@Table (name=\"mytable\")\r\npublic class Entity {\r\n\t\r\n\t@Id\r\n\tprivate long Id;\r\n\t\r\n\t@Column(name = \"myname\")\r\n\tprivate String name;\r\n\t\r\n\t// @Column is not required\r\n\tprivate int age;\r\n\t\r\n\t@Transient\r\n\tprivate BigDecimal calculable;\r\n\t\r\n\t// public getters/setters ...\r\n}\r\n```\r\nCQL3 Statement\r\n```\r\n   CREATE TABLE IF NOT EXISTS ks.mytable (id bigint, myname text, age int, PRIMARY KEY(id))\r\n```     \r\n\r\n<a name=\"mapping_index\"/>\t\r\n#### Mapping Indexes\r\n```java\r\nimport javax.persistence.Id;\r\nimport javax.persistence.Table;\r\nimport javax.persistence.Column\r\nimport javax.persistence.Index\r\nimport java.util.UUID\r\n\r\n@Table (name=\"mytable\", \r\nindexes = {\r\n\t@Index(name=\"entity_email_idx\", columnList=\"email\" ), \r\n\t@Index(name=\"entity_name_idx\", columnList=\"myname\" ) \r\n})\r\npublic class Entity {\r\n\t\r\n\t@Id\r\n\tprivate java.util.UUID code;\r\n\t\r\n\t@Column(name = \"myname\")\r\n\tprivate String name;\r\n\tprivate String email;\r\n\t// public getters/setters ...\r\n}\r\n```\r\nCQL3 Statement\r\n```\r\n   \tCREATE TABLE IF NOT EXISTS ks.mytable (code uuid, myname text, email text,  PRIMARY KEY(code)); \r\n\tCREATE INDEX IF NOT EXISTS entity_email_idx ON ks.mytable(email);  \r\n\tCREATE INDEX IF NOT EXISTS entity_name_idx ON ks.mytable(myname);\r\n```   \r\n\r\n<a name=\"mapping_composite\"/>\r\n#### Compound Primary Key\r\n```java\r\nimport java.math.BigInteger;\r\nimport java.util.Date;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\nimport javax.persistence.Id;\r\nimport javax.persistence.Table;\r\n\r\n@Table(name=\"entity\")\r\npublic class Entity {\r\n\t@Id\r\n\tprivate java.util.UUID id;\r\n\tprivate List<String> cats;\r\n\tprivate Set<Date> dogs;\r\n\tprivate Map<String, BigInteger> pets;\r\n\t\r\n\t// public getters/setters ...\r\n}\r\n```\r\n```java\r\nimport javax.persistence.Embeddable;\t\r\n\r\n@Embeddable\r\npublic class CompositeKey {\r\n\tprivate String name;\r\n\tprivate int rank;\r\n\t// public getters/setters ...\r\n}\r\n```\r\n```java\r\n\r\nimport javax.persistence.Table;\r\nimport javax.persistence.EmbeddedId;\t\r\n\r\n@Table(name=\"entity\")\r\npublic class Entity {\r\n\t@EmbeddedId\r\n\tprivate CompositeKey key;\r\n\tprivate String email;\r\n\t// public getters/setters ...\r\n}\r\n```\r\nCQL3 Statement\r\n```\r\n   CREATE TABLE IF NOT EXISTS ks.entity (name text,  rank int, email text,  PRIMARY KEY(name, rank))\r\n```     \r\n\r\n<a name=\"mapping_partition\"/>\r\n#### Composite Partition Key\r\n```java\r\nimport javax.persistence.Embeddable;\t\r\n\r\n@Embeddable\r\npublic class PartitionKey {\r\n\tprivate String firstName;\r\n\tprivate String lastName;\r\n\t// public getters/setters ...\r\n}\r\n```\r\n```java\r\nimport javax.persistence.Embeddable;\t\r\n\r\n@Embeddable\r\npublic class CompositeKey {\r\n\t@EmbeddedId\r\n\tprivate PartitionKey key;\r\n\tprivate int age;\r\n\t// public getters/setters ...\r\n}\r\n```\r\n```java\r\nimport javax.persistence.Table;\r\nimport javax.persistence.EmbeddedId;\t\r\n\r\n@Table(name=\"entity\")\r\npublic class Entity {\r\n\t@EmbeddedId\r\n\tprivate CompositeKey key;\r\n\tprivate String email;\r\n\t// public getters/setters ...\r\n}\r\n```\r\nCQL3 Statement\r\n```\r\n   CREATE TABLE IF NOT EXISTS ks.entity (firstname text, lastname text, age int, email text,  PRIMARY KEY((firstname, lastname), age))\r\n```     \r\n\r\n<a name=\"mapping_properties\"/>\r\n#### Table Properties  \r\nThis feature is not JPA standard! [ Read more about C* Table properties ] (http://www.datastax.com/documentation/cql/3.1/cql/cql_reference/cql_storage_options_c.html)\r\n```java\r\nimport javax.persistence.Id;\r\nimport javax.persistence.Table;\r\nimport javax.persistence.Column\r\n\r\nimport com.datastax.driver.mapping.annotation.TableProperties;\r\nimport com.datastax.driver.mapping.annotation.TableProperty;\r\n\r\n@Table (name=\"mytable\")\r\n@TableProperties(values = {\r\n\t@TableProperty(value=\"comment='Important records'\"),\r\n\t@TableProperty(value=\"read_repair_chance = 1.0\"),\r\n\t@TableProperty(value=\"compression ={ 'sstable_compression' : 'DeflateCompressor', 'chunk_length_kb' : 64 }\")\r\n})\r\npublic class Entity {\r\n\t\r\n\t@Id\r\n\tprivate long Id;\r\n\tprivate String name;\r\n\t// public getters/setters ...\r\n}\r\n```\r\nCQL3 Statement\r\n```\r\n   CREATE TABLE IF NOT EXISTS ks.mytable (id bigint, name text, PRIMARY KEY(id)) WITH comment='Important records' AND read_repair_chance = 1.0 AND compression ={ 'sstable_compression' : 'DeflateCompressor', 'chunk_length_kb' : 64 }\r\n```     \r\n\r\n<a name=\"mapping_datatype\"/>\r\n#### Override Column Data Type.   \r\nDatastax defines [data type mapping from Java to C*] (http://www.datastax.com/documentation/developer/java-driver/2.0/java-driver/reference/javaClass2Cql3Datatypes_r.html).  \r\nThis addon defines opposite way mapping. [You can explore daults here](#metadata).    \r\nBut in case you don't like defaults you are able to override the type on the column level.   \r\nFor example you want to leverage \"time UUID\" for timeseries data instead of \"random UUID\".  \r\n```java\r\nimport javax.persistence.Id;\r\nimport javax.persistence.Table;\r\nimport javax.persistence.Column\r\n\r\n@Table (name=\"mytable\")\r\npublic class Entity {\r\n\t\r\n\t@Id\r\n\t@Column(name=\"uid\", columnDefinition=\"timeuuid\") // case insensitive\r\n\tprivate UUID uid;\t\t\r\n\t\r\n\t@Column(name=\"name\", columnDefinition=\"VarChaR\") // case insensitive\r\n\tprivate String name;\r\n\t// public getters/setters ...\r\n}\r\n```\r\nCQL3 Statement\r\n```\r\n   CREATE TABLE IF NOT EXISTS ks.mytable (uid timeuuid, name varchar, PRIMARY KEY(uid))\r\n```     \r\n\t\r\n<a name=\"mapping_mixed\"/>\r\n#### Mixed Case for Column Names  \r\n[C* converts all names to lowercase](http://www.datastax.com/documentation/cql/3.1/cql/cql_reference/ucase-lcase_r.html). This is default and recommended approach.  \r\nBut in case you need enforce the case you will need to wrap you names in double quotes. \r\n```java\r\nimport javax.persistence.Id;\r\nimport javax.persistence.Table;\r\nimport javax.persistence.Column\r\n\r\n@Table (name=\"mytable\")\r\npublic class Entity {\r\n\t\r\n\t@Id\r\n\t@Column(name = \"\\\"KEY\\\"\")\r\n\tprivate int id;\r\n\tprivate String firstName;\r\n\r\n\t@Column(name = \"\\\"last_NAME\\\"\")\r\n\tprivate String lastName;\r\n\r\n\t@Column(name = \"AGE\")\r\n\tprivate int age;\r\n\t// public getters/setters ...\r\n}\r\n```\r\nCQL3 Statement\r\n```\r\n   CREATE TABLE IF NOT EXISTS ks.mytable (\"KEY\" int, firstName text, \"last_NAME\" text, AGE int, PRIMARY KEY(\"KEY\"))\r\n```     \r\n\r\n<a name=\"collections\"/>\r\n### Collections\r\n   \r\n<a name=\"mapping_collections\"/>\r\n#### Mapping\r\n\r\nCollections must have generic type defined. Only java.util.List, Map and Set are allowed.  \r\nBy default implementation of HashMap, HashSet and ArrayList are used.\r\nIf you are unhappy with that fact and would like your data to be baked with specific collection implementation you can apply an annotation as shown below.\r\n```java\r\n\timport com.datastax.driver.mapping.annotation.CollectionType;\r\n\t...\r\n\t@CollectionType(LinkedList.class)\r\n\tprivate List<String> cats;\r\n\t\r\n\t@CollectionType(TreeSet.class)\r\n\tprivate Set<Date> dogs;\r\n\r\n\t@CollectionType(TreeMap.class)\r\n\tprivate Map<String, BigInteger> pets;\r\n}\r\n```\r\nNOTE: this is strictly java side feature and does not effect how your data stored in C*.     \r\n\r\nCQL3 Statement\r\n```\r\n   CREATE TABLE IF NOT EXISTS ks.entity (id uuid, cats list<text>, dogs set<timestamp>, pets map<text, varint>,  PRIMARY KEY(id))\r\n```     \r\nFor more info on collections please refer [Datastax Using Collection] (http://www.datastax.com/documentation/cql/3.1/cql/cql_using/use_collections_c.html)\r\n\r\n<a name=\"collections_opt\"/>\r\n#### Optimized operations  \r\nYou can work with your collection properties as you would normally work with other entity properties.  \r\nIn addition C* provides optimized operations on collections. Those operations do not require to load and save the whole entity. C* allows us directly manipulate collections.   \r\n\r\n\r\n<a name=\"collections_list\"/>\r\n- List operations\r\n```java\r\n// append item to list\r\nmappingSession.append(id, Entity.class, \"cats\", \"Black Cat\");\r\n\r\n// append item to be expired in 5 sec\r\nmappingSession.append(id, Entity.class, \"cats\", \"Expired Cat\", new WriteOptions().setTtl(5));\r\n\r\n// prepend item\r\nmappingSession.prepend(id, Entity.class, \"cats\", \"First Cat\");\r\n\r\n// replace item at specified index\r\nmappingSession.replaceAt(id, Entity.class, \"cats\", \"Grey Cat\", 1);\r\n\r\n// append List of items\r\nList<String> addCats = new ArrayList<String>();\r\naddCats.add(\"Red Cat\");\r\naddCats.add(\"Green Cat\");\r\nmappingSession.append(id, Entity.class, \"cats\", addCats);\r\n\r\n// remove item\r\nmappingSession.remove(id, Entity.class, \"cats\", \"Grey Cat\");\r\n\r\n// remove List of items\r\nList<String> removeCats = new ArrayList<String>();\r\nremoveCats.add(\"Red Cat\");\r\nremoveCats.add(\"Green Cat\");\r\nmappingSession.remove(id, Entity.class, \"cats\", removeCats);\r\n\r\n// remove all items\r\nmappingSession.deleteValue(id, Entity.class, \"cats\");\r\n```\r\n\r\n<a name=\"collections_set\"/>\r\n- Set operations\r\n```java\r\n// append item\r\nmappingSession.append(id, Entity.class, \"dogs\", \"Black Dog\");\r\n\r\n// append item to be expired in 5 sec\r\nmappingSession.append(id, Entity.class, \"dogs\", \"Expired Dog\", new WriteOptions().setTtl(5));\r\n\r\n// append Set of items\r\nSet<String> addDogs = new HashSet<String>();\r\naddDogs.add(\"Red Dog\");\r\naddDogs.add(\"Green Dog\");\r\nmappingSession.append(id, Entity.class, \"dogs\", addDogs);\r\n\r\n// remove item\r\nmappingSession.remove(id, Entity.class, \"dogs\", \"Black Dog\");\r\n\r\n// remove Set of items\r\nSet<String> removeDogs = new HashSet<String>();\r\nremoveDogs.add(\"Red Dog\");\r\nremoveDogs.add(\"Green Dog\");\r\nmappingSession.remove(id, Entity.class, \"dogs\", removeDogs);\r\n\r\n// remove all items\r\nmappingSession.deleteValue(id, Entity.class, \"dogs\");\r\n```\r\n\r\n<a name=\"collections_map\"/>\r\n- Map operations\r\n```java\r\n/** append item */\r\nMap<String, BigInteger> pets = new HashMap<String, BigInteger>();\r\npets.put(\"Red Dogs\", 25);\r\npets.put(\"Black Cats\", 50);\r\nmappingSession.append(id, Entity.class, \"pets\", pets);\r\n\r\n/** append items to be expired in 5 sec */\r\nMap<String, BigInteger> pets = new HashMap<String, BigInteger>();\r\npets.put(\"Green Dogs\", 25);\r\npets.put(\"Brown Cats\", 50);\r\nmappingSession.append(id, Entity.class, \"pets\", pets, new WriteOptions().setTtl(5));\r\n\r\n/** remove all items */\r\nmappingSession.deleteValue(id, Entity.class, \"pets\");\r\n```\r\n\r\n<a name=\"lock\"/>\r\n### Optimistic Lock\r\nC* does not support locking. But it provides ability for [Optimistic Concurrency Control] (http://en.wikipedia.org/wiki/Optimistic_concurrency_control).  \r\nWhile running, transactions use data resources without acquiring locks on those resources. Before committing, each transaction verifies that no other transaction has modified the data it has read. If the check reveals conflicting modifications, the committing transaction rolls back and can be restarted.  \r\nThis section explains how you can achieve this with C* and Mapping Add-on\r\n\r\n\r\n<a name=\"lock_transactions\"/>\r\n- Lightweight Transactions  \r\nI don't know why they call it Lightweight Transactions. Those transactions are much heavier than normal C* transactions. Read more about [Datastax Lightweight Transactions.] (http://www.datastax.com/documentation/cassandra/2.0/cassandra/dml/dml_ltwt_transaction_c.html)  \r\nC* supports conditional UPDATE/INSERT using IF/IF NOT EXISTS keywords. When \"IF\" condition is not met write doesn't happen. The boolean flag \"[applied]\" is returned.\r\n\r\n<a name=\"lock_version\"/>\r\n- @Version  \r\nMapping Add-on enables optimistic locking using annotation @Version.  \r\nThe property must be of \"long\" data type. Whenever you save entity the version get incremented and as result of operation updated entity is retirned. If you try to save not-the-latest one then \"null\" will be returned instead and no error will be thrown.\r\n```java\r\n\t\r\n\timport javax.persistence.Id;\r\n\timport javax.persistence.Table;\r\n\timport javax.persistence.Version;\t\r\n\t\r\n\t@Table(name=\"entity\")\r\n\tpublic class EntityWithVersion {\r\n\t\t@Id\r\n\t\tprivate java.util.UUID id;\r\n\t\r\n\t\t@Version\r\n\t\tprivate long version;\t\r\n\t\t// public getters/setters ...\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void entityWithVersionTest() throws Exception {\r\n\t\tUUID id = UUID.randomUUID();\r\n\t\tEntityWithVersion obj = new EntityWithVersion();\r\n\t\tobj.setId(id);\r\n\t\tobj.setName(\"ver1\"); \r\n\t\t\r\n\t\tEntityWithVersion loaded = mappingSession.get(EntityWithVersion.class, id);\r\n\t\tassertNull(loaded);\r\n\t\t\r\n\t\t// save object ver1 \r\n\t\tEntityWithVersion saved = mappingSession.save(obj);\r\n\t\t\r\n\t\t// get object ver1\r\n\t\tEntityWithVersion obj1 = mappingSession.get(EntityWithVersion.class, id);\r\n\t\tassertEquals(obj1, saved);\r\n\t\tassertEquals(1, saved.getVersion());\r\n\t\t\r\n\t\t// save object ver2\r\n\t\tsaved = mappingSession.save(saved);\r\n\t\tEntityWithVersion obj2 = mappingSession.get(EntityWithVersion.class, id);\r\n\t\tassertEquals(obj2, saved);\r\n\t\tassertEquals(2, saved.getVersion());\t\t\r\n\t\t\r\n\t\tsaved = mappingSession.save(obj1);\r\n\t\tassertNull(saved);\r\n\t}\t\t\r\n```\r\n\r\n<a name=\"batch\"/>\r\n### Batch\r\n```java\r\n\t\t\r\n\tmappingSession.withBatch()\r\n\t\t.save(entityA)\r\n\t\t.save(entityB)\r\n\t\t.delete(entityC)\r\n\t\t.delete(entityD)\r\n\t\t.execute();\r\n```\r\n\r\n\r\n<a name=\"nested\"/>\r\n### Nested Entities\r\nThis section shows how you can support nested entities with C* and Mapping Add-on.\r\n```java\r\n\t\r\n\t@Table(name=\"entity_a\")\r\n\tpublic class EntityA {\r\n\t\t@Id\r\n\t\tprivate UUID id;\r\n\t\r\n\t\t// public getters/setters ...\r\n\t}\r\n\t\r\n\t@Table(name=\"entity_b\")\r\n\tpublic class EntityB {\r\n\t\t@Id\r\n\t\tprivate UUID id;\r\n\t\t\r\n\t\t// reference on EntityA \r\n\t\tprivate UUID refA;\r\n\t\t// public getters/setters ...\r\n\t}\t\r\n\t\r\n\tpublic class TestNested() {\r\n\t\t\r\n\t\t@Test\r\n\t\tpublic void saveNested() throws Exception {\r\n\t\t\tEntityA a = new EntityA();\r\n\t\t\tmappingSession.save(a);\r\n\t\t\t\r\n\t\t\tEntityB b = new EntityB();\r\n\t\t\tb.setRefA(a.getId());\r\n\t\t\tmappingSession.save(b);\r\n\t\t}\r\n\r\n\t\t@Test\r\n\t\tpublic void loadNested() throws Exception {\r\n\t\t\tUUID bId = some_id;\r\n\t\t\tEntityB b = mappingSession.load(bId);\r\n\t\t\tEntityA a = mappingSession.load(b.getRefA());\r\n\t\t}\r\n\t\t\r\n\t}\r\n```\r\n\r\n\r\n<a name=\"queries_mapping\"/>\r\n### Mapping Custom Queries\r\n\r\n<a name=\"queries_howto\"/>\r\n- How To Run  \r\nThere are two ways to run and map the query:  \r\n\t1) run using mapping session\r\n\t```java\r\n\timport com.datastax.driver.mapping.MappingSession;\r\n\t...\r\n\tList<Entity> result = mappingSession.getByQuery(Entity.class, query);\r\n\t```\r\n\r\n\t2) run using DataStax session and map the ResultSet\r\n\t```java\r\n\timport com.datastax.driver.core.Session;\r\n\timport com.datastax.driver.core.ResultSet;\r\n\timport com.datastax.driver.mapping.MappingSession;\r\n\t...\r\n\tResultSet rs = session.execute(query);\t\r\n\tList<Entity> result = mappingSession.getFromResultSet(Entity.class, rs);\r\n\t```\r\n\r\n<a name=\"queries_gnomes\"/>\r\n- Any-to-Any and Magic Gnomes  \r\nThis is the coolest feature of the module. Your Entity doesn't have to match the table.  \r\nYou can populate any entity from any query (Any-to-Any).  \r\nConsider example: \r\n```java\r\n\tpublic class AnyObject {\r\n\t\tprivate String name;\r\n\t\tprivate int age;\r\n\t\t// public getters/setters ...\r\n\t}\r\n```\r\nYou can populate this object from any ResultSet which contains 'name' and 'age' columns.  \r\n```java\r\n\tResultSet rs = session.execute(\"SELECT name, age, birth_date, salary FROM person\");\t\r\n\tList<AnyObject> result = mappingSession.getFromResultSet(AnyObject.class, rs);\r\n```\r\nIn this particular case 'name' and 'age' will be populated on 'AnyObject'. 'birth_date' and 'salary' will be ignored and no errors will be thrown.  \r\nThe biggest advantage that we can reuse the same entity to query different results from even different tables.\r\nEntity doesn't have to map, match or relate to the table at all. \r\nMany thank to magic gnomes under the hood making all these work.\r\n\r\n<a name=\"queries_building\"/>\r\n### Building Custom Queries\r\n\t\r\n<a name=\"queries_cql\"/>\r\n- CQL String\r\n```java\r\n\timport com.datastax.driver.mapping.MappingSession;\r\n\t... \r\n\t\r\n\t// build query\r\n\tString query = \"SELECT name, age, birth_date, salary FROM person\");\t\r\n\t\r\n\t// run query\t\t\t\t\t\t\r\n\tList<Entity> result = mappingSession.getByQuery(Entity.class, query);\t\r\n```\r\n\r\n<a name=\"queries_builder\"/>\r\n- QueryBuilder (Better)  \r\nDatastax Driver shipped with a tool to build CQL statement.  \r\nYou can build your query with Datastax QueryBuilder and map ResultSet on Entity.  \r\nQueryBuilder ensures you build correct CQL.\r\n```java\r\n\t\t\t\t\r\n\timport com.datastax.driver.core.Statement;\r\n\timport com.datastax.driver.core.querybuilder.QueryBuilder;\r\n\timport com.datastax.driver.mapping.MappingSession;\r\n\t...\r\n\r\n\t// build query\r\n\tStatement query = QueryBuilder.select().all()\r\n\t\t.from(\"your_keyspace\", \"your_table\").where(eq(\"column\", value));\r\n\t\r\n\t// run query\t\t\t\t\t\t\r\n\tList<Entity> result = mappingSession.getByQuery(Entity.class, query);\r\n```\r\n\r\n<a name=\"queries_meta\"/>\r\n- QueryBuilder with EntityMetadata (Even Better)  \r\nIn early stages you may often change table and column names.  \r\nTo avoid changing queries each time you rename something you can employ entity metadata.\r\n```java\r\n\timport com.datastax.driver.core.Statement;\r\n\timport com.datastax.driver.core.querybuilder.QueryBuilder;\r\n\timport com.datastax.driver.mapping.MappingSession;\r\n\timport com.datastax.driver.mapping.EntityFieldMetaData;\r\n\timport com.datastax.driver.mapping.EntityTypeMetadata;\t\r\n\t...\t\t\t\r\n\t\r\n\t// get Entity Metadata\r\n\tEntityTypeMetadata emeta = EntityTypeParser.getEntityMetadata(Entity.class);\r\n\t\r\n\t// get field metadata by property/field name\r\n\tEntityFieldMetaData fmeta = emeta.getFieldMetadata(field_name); \r\n\t\r\n\t// build query.\r\n\tStatement query = QueryBuilder.select().all()\r\n\t\t.from(\"your_keyspace\", emeta.getTableName()).where(eq(fmeta.getColumnName(), value));\r\n\t\t\t\t\t\t\t\r\n\t// run query\r\n\tList<Entity> result = mappingSession.getByQuery(Entity.class, query);\r\n```\r\n\r\n<a name=\"under\"/>\r\n### Under The Hood\r\n\r\n<a name=\"pscache\"/>\t   \r\n#### Prepared Statement Cache\r\nFor the performance gain most update/select/delete statements are built as Prepared Statements.\r\nPrepared Statements are reusable and placed in the static cache.\r\nCache is Guava Cache implementation initialized as:\r\n```java\r\n.expireAfterAccess(5, TimeUnit.MINUTES)\r\n.maximumSize(1000)\r\n.concurrencyLevel(4)\r\n```\r\n\r\nIf you want to tune the cache for better performance you can do it as:\r\n```java\r\nCache<String, PreparedStatement> cache = CacheBuilder\r\n\t.newBuilder()\r\n\t.expireAfterAccess(60, TimeUnit.MINUTES)\r\n\t.maximumSize(10000)\r\n\t.concurrencyLevel(8)\r\n\t.build();\r\n\r\nMappingSession.setStatementCache(cache);\r\n```\r\n[More about Guava Cache](https://code.google.com/p/guava-libraries/wiki/CachesExplained)  \r\n\r\n\t   \r\n<a name=\"sync\"/>\t   \r\n#### How Entity get synchronized\r\nThe table structure is automatically synchronized with the entity definition on the first use of the entity.  \r\nAny SessionMapping call internally will check if the entity has already been synchronized and if not   \r\nit will run SchemaSync.sync. You can use sync API directly as:  \r\n\r\n```java\r\n\t// create or alter\r\n\timport com.datastax.driver.mapping.schemasync.SchemaSync;\r\n\t...\r\n\tSchemaSync.sync(keyspace, session, Entity.class);\r\n```\r\n```java\r\n\t// drop table\r\n\timport com.datastax.driver.mapping.schemasync.SchemaSync;\r\n\t...\r\n\tSchemaSync.drop(keyspace, session, Entity.class);\r\n```\r\n\r\nYou don't need to use this API unless you have reasons.   \r\nSuch as unittests or if you want to gain few milliseconds on the first use  \r\nyou may want to invoke the synchronization on the application start up instead. \r\n\r\nAs the project is evolving sometimes there is need to refactor entity, add or delete properties and indexes. \r\nAgain this all taken care automatically but with certain restrictions.     \r\nPlease read to understand what will and will not be altered and synchronized.\r\n   \r\nNot Alterable\r\n   - add/delete/rename primary key columns. (C* restriction)  \r\n   - change column data type to incompatible one, such as string to number. (C* restriction)  \r\n   - change property name which is not annotated as @Column. This will be understood as a new property. \r\n   \t\r\nAlterable\r\n   - add new property.\r\n   - delete property.\r\n   - add index on column.\r\n   - change datatype to compatible one. Compatibility is enforced by C*.\t\r\n   \t\t\r\n<a name=\"metadata\"/>\r\n#### Entity Metadata and Data Types\r\n   \r\nYou may want to access Entity metadata if you are building custom Statements.    \r\nEntity Metadata contains corresponding table and column names.  \r\nEntity Metadata can be easily accessed anywhere in your code as:\r\n```java\t\r\n\tEntityTypeMetadata emeta = EntityTypeParser.getEntityMetadata(Entity.class)\r\n\temeta.getTableName(); // corresponding table name in C*\r\n\t\r\n\t// get field meta info by property name\r\n\tEntityFieldMetaData fdata = emeta.getFieldMetadata(\"email\");\r\n\t \r\n\t// corresponding column name in C*\r\n\tString columnName = fdata.getColumnName(); \r\n\t\r\n\t // all the persistent fields on entity\r\n\tList<EntityFieldMetaData> fields = emeta.getFields();\r\n```\t\r\nDatastax driver has mapping of datastax types to java. But not all types are mapped as 1-to-1.  \r\n[CQL3 data types to Java types](http://www.datastax.com/documentation/developer/java-driver/1.0/webhelp/index.html#java-driver/reference/javaClass2Cql3Datatypes_r.html)  \r\nIn order the mapping to work the module defines backward mapping for the types.  \r\n\r\nJava type | CQL3 data type\r\n--- | ---\r\nint|int\r\nlong|bigint\r\nfloat|float\r\ndouble|double\r\nboolean|boolean\r\njava.lang.Double|double\r\njava.nio.ByteBuffer|blob\r\njava.math.BigDecimal|decimal\r\njava.lang.String|text\r\njava.util.Date|timestamp\r\njava.lang.Boolean|boolean\r\njava.lang.Integer|int\r\njava.lang.Long|bigint\r\njava.util.Map|map\r\njava.lang.Float|float\r\njava.util.Set|set\r\njava.math.BigInteger|varint\r\njava.util.UUID|uuid\r\njava.util.List|list\r\n\r\nYou can override defaults as:\r\n```java\r\n\timport com.datastax.driver.core.DataType;\r\n\t...\r\n\tMap<Class<?>, DataType.Name> mapping = new HashMap<Class<?>, DataType.Name>();\r\n\t.... populate the map\r\n\tEntityTypeParser.setDataTypeMapping(mapping);\r\n```\r\nOr override individual type:\r\n```java\r\n\timport com.datastax.driver.core.DataType;\r\n\t...\r\n\tEntityTypeParser.overrideDataTypeMapping(javaClass, DataType.Name)\r\n```\r\n\r\n<a name=\"spring\"/>\r\n### Spring Framework Example \r\n\r\n- Configure properties.  \r\nLet's imagine we have a property file /META-INF/cassandra.properties:\r\n  ```\r\n   \tcassandra.keyspace=your_keyspace\r\n\tcassandra.node=127.0.0.1\r\n   ```\r\n   \r\n- Include properties in spring config:\r\n   ```xml\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\t<beans:beans xmlns=\"http://www.springframework.org/schema/mvc\"\r\n\t\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\t\txmlns:beans=\"http://www.springframework.org/schema/beans\"\r\n\t\txmlns:context=\"http://www.springframework.org/schema/context\"\r\n\t\txsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\r\n\t\thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n\t\t\r\n\t\t<!-- Enables the Spring MVC @Controller programming model -->\r\n\t\t<annotation-driven />\r\n\r\n\t\t<context:property-placeholder location=\"classpath*:/META-INF/cassandra.properties\"/>  \r\n\t\r\n\t\t<context:component-scan base-package=\"your.package.path\" />\r\n\t </beans:beans> \r\n   ```\r\n\r\n- Define Entity\r\n\t```java\r\n\t\timport java.util.UUID;\r\n\t\t\r\n\t\timport javax.persistence.Entity;\r\n\t\timport javax.persistence.Column;\r\n\t\timport javax.persistence.Id;\r\n\t\timport javax.persistence.Table;\r\n\t\t\r\n\t\t@Entity\r\n\t\t@Table(name=\"account\", indexes = {@Index(name=\"account_email_idx\", columnList=\"email\" )})\r\n\t\tpublic class Account {\r\n\t\t\t@Id\r\n\t\t\tprivate String id = UUID.randomUUID().toString();\r\n\t\t\t\r\n\t\t\t@Column(name=\"email\") \r\n\t\t\tprivate String email;\t\t\t\r\n\t\t\t\r\n\t\t\tpublic String getId() {\r\n\t\t\t\treturn id;\r\n\t\t\t}\r\n\t\t\tpublic void setId(String id) {\r\n\t\t\t\tthis.id = id;\r\n\t\t\t}\t\t\t\r\n\t\t\tpublic String getEmail() {\r\n\t\t\t\treturn email;\r\n\t\t\t}\r\n\t\t\tpublic void setEmail(String email) {\r\n\t\t\t\tthis.email = email;\r\n\t\t\t}\r\n\t\t}\r\n\t```\r\n\t\t   \r\n- Create session factory for C*:\r\n\t\r\n\t```java\r\n\t\timport org.springframework.beans.factory.annotation.Value;\r\n\t\timport org.springframework.stereotype.Repository;\r\n\t\timport com.datastax.driver.core.Cluster;\r\n\t\timport com.datastax.driver.core.Session;\r\n\t\timport com.datastax.driver.mapping.MappingSession;\r\n\t\timport com.datastax.driver.mapping.schemasync.SchemaSync;\r\n\t\t\r\n\t\t@Repository\r\n\t\tpublic class CassandraSessionFactory {\r\n\t\t\t\r\n\t\t\t@Value(\"${cassandra.keyspace}\")\r\n\t\t\tprivate String keyspace;\r\n\t\t\t\r\n\t\t\t@Value(\"${cassandra.node}\")\r\n\t\t\tprivate String node;\r\n\t\t\t\r\n\t\t\tprivate Cluster cluster;\r\n\t\t\tprivate Session session;\r\n\t\t\tprivate MappingSession mappingSession;\r\n\t\t\t\t\r\n\t\t\tpublic Session getSession() {\r\n\t\t\t\tif (session == null) {\r\n\t\t\t\t\tconnect();\r\n\t\t\t\t}\r\n\t\t\t\treturn session;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tpublic MappingSession getMappingSession() {\r\n\t\t\t\tif (session == null) {\r\n\t\t\t\t\tconnect();\r\n\t\t\t\t}\r\n\t\t\t\treturn mappingSession;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tpublic String getKeyspace() {\r\n\t\t\t\treturn keyspace;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/** only 1 thread is permitted to open connection */\r\n\t\t\tprotected synchronized void connect() {\r\n\t\t\t\tif (session == null) {\r\n\t\t\t\t\tcluster = Cluster.builder().addContactPoint(node).build();\r\n\t\t\t\t\tsession = cluster.connect();\r\n\t\t\t\t\tsession.execute(\"CREATE KEYSPACE IF NOT EXISTS \"+ getKeyspace() +\r\n\t\t\t\t\t\t\" WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : 3 }\");\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tmappingSession = new MappingSession(getKeyspace(), getSession());\r\n\t\t\t\t}\t\r\n\t\t\t}\r\n\t\t}\r\n\t```\r\n\t\r\n- Create DAO and inject factory into it:\r\n\t\t\r\n\t```java\t\t\r\n\t\timport java.util.List;\r\n\t\t\r\n\t\timport org.springframework.beans.factory.annotation.Autowired;\r\n\t\timport org.springframework.stereotype.Repository;\r\n\t\t\r\n\t\timport static com.datastax.driver.core.querybuilder.QueryBuilder.eq;\r\n\t\timport com.datastax.driver.core.Statement;\r\n\t\timport com.datastax.driver.core.querybuilder.QueryBuilder;\r\n\t\timport com.datastax.driver.mapping.EntityFieldMetaData;\r\n\t\timport com.datastax.driver.mapping.EntityTypeMetadata;\r\n\t\timport com.datastax.driver.mapping.EntityTypeParser;\r\n\t\timport com.datastax.driver.mapping.MappingSession;\t\r\n\t\t\r\n\t\t@Repository\r\n\t\tpublic class AccountDAO {\r\n\t\t\t\r\n\t\t\t@Autowired\r\n\t\t\tCassandraSessionFactory sf;\r\n\t\t\t\r\n\t\t\tpublic void save(Account account) {\r\n\t\t\t\tsf.getMappingSession().save(account);\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tpublic void delete(Account account) {\r\n\t\t\t\tsf.getMappingSession().delete(account);\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tpublic Account getById(Object id) {\r\n\t\t\t\treturn sf.getMappingSession().get(ChatAccount.class, id);\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tpublic Account getByEmail(String email) throws Exception {\r\n\t\t\t\t\r\n\t\t\t\tStatement stmt = buildQueryForColumn(\"email\", email);\r\n\t\t\t\tif (stmt==null) return null;\r\n\t\t\t\t\r\n\t\t\t\tList<Account> result = sf.getMappingSession().getByQuery(Account.class, stmt);\r\n\t\t\t\tif (result == null || result.size()==0) return null;\r\n\t\t\r\n\t\t\t\treturn result.get(0);\r\n\t\t\t}\r\n\t\t\r\n\t\t\t\r\n\t\t\t/** Sample Building Select Statement for a single column with Datastax QueryBuilder */\r\n\t\t\tprotected Statement buildQueryForColumn(String propName, Object propVal) {\r\n\t\t\t\tEntityTypeMetadata emeta = EntityTypeParser.getEntityMetadata(Account.class);\r\n\t\t\t\tEntityFieldMetaData fmeta = emeta.getFieldMetadata(propName);\r\n\t\t\t\tif (fmeta != null) {\r\n\t\t\t\t\treturn QueryBuilder\r\n\t\t\t\t\t\t\t.select().all()\r\n\t\t\t\t\t\t\t.from(sf.getKeyspace(), emeta.getTableName())\r\n\t\t\t\t\t\t\t.where(eq(fmeta.getColumnName(), propVal));\r\n\t\t\t\t}\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t```\r\n","google":"UA-23057632-1","note":"Don't delete this file! It's used internally to help with page regeneration."}